//
//  ViewController.swift
//  FakeContactsGenerator
//
//  Created by YuehYang Wu on 12/27/16.
//  Copyright Â© 2016 YuehYang Wu. All rights reserved.
//

import UIKit
import Contacts

class ViewController: UIViewController {

    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var consoleTextView: UITextView!
    
    let store = CNContactStore()
    let FakeContactKey = "Generated by fake contacts"
    
    let names: [String] = {
        let path = Bundle.main.path(forResource: "Names", ofType: "plist")!
        let names = NSArray(contentsOfFile: path)!
        return names as! [String]
    }()
    
    let phoneNumbers: [String] = {
        let path = Bundle.main.path(forResource: "Phone", ofType: "plist")!
        let phoneNumbers = NSArray(contentsOfFile: path)!
        return phoneNumbers as! [String]
    }()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
        tableView.dataSource = self
        if names.count != phoneNumbers.count {
            write(toConsole: "Names.plist and Phone.plist has different number of items. Please fix this or it may crashed")
        }
    }

    @IBAction func write(_ sender: Any) {
        store.requestAccess(for: .contacts) { (granted, error) in
            DispatchQueue.main.async {
                if !granted  {
                    self.write(toConsole: "contacts permission denied.")
                } else {
                    self.write()
                }
            }
        }
    }
    
    @IBAction func clear(_ sender: Any) {
        store.requestAccess(for: .contacts) { (granted, error) in
            DispatchQueue.main.async {
                if !granted  {
                    self.write(toConsole: "contacts permission denied.")
                } else {
                    self.clear()
                }
            }
        }
    }
    
    @IBAction func testReading(_ sender: Any) {
        testReading()
    }
    
    func write() {
        let saveRequest = CNSaveRequest()
        write(toConsole: "writing to contacts, busy...")
        DispatchQueue.global().async {
            for index in 0..<self.names.count {
                let contact = CNMutableContact()
                let (givenName, familyName) = (self.names[index].components(separatedBy: " ")[0],
                                               self.names[index].components(separatedBy: " ")[1])
                contact.givenName = givenName
                contact.familyName = familyName
                let phone = CNLabeledValue(label: CNLabelPhoneNumberMain, value: CNPhoneNumber(stringValue: self.phoneNumbers[index]))
                contact.phoneNumbers = [phone]
                contact.note = self.FakeContactKey
                saveRequest.add(contact, toContainerWithIdentifier: nil)
            }
            do {
                try self.store.execute(saveRequest)
                self.write(toConsole: "successfully wrote contacts.\n")
            } catch let error {
                self.write(toConsole: error.localizedDescription)
            }
        }
    }
    
    func clear() {
        guard let containers = try? store.containers(matching: nil) else { return }
        write(toConsole: "deleteing contacts, busy...")
        DispatchQueue.global().async {
            let keysToFetch: [CNKeyDescriptor] = [
                CNContactPhoneNumbersKey as CNKeyDescriptor,
                CNContactNoteKey as CNKeyDescriptor
            ]
            var contacts: [CNContact] = []
            for container in containers {
                let predicate = CNContact.predicateForContactsInContainer(withIdentifier: container.identifier)
                guard let unifiedContacts = try? self.store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch) else { continue }
                contacts += unifiedContacts
            }
            let saveRequest = CNSaveRequest()
            var deletedCount = 0
            for contact in contacts {
                guard contact.note == self.FakeContactKey else { continue }
                guard let mutableContact = contact.mutableCopy() as? CNMutableContact else { continue }
                saveRequest.delete(mutableContact)
                deletedCount += 1
            }
            do {
                try self.store.execute(saveRequest)
                self.write(toConsole: "successfully deleted \(deletedCount) contacts\n")
            } catch let error {
                self.write(toConsole: error.localizedDescription)
            }
        }
    }
    
    func write(toConsole text: String) {
        DispatchQueue.main.async {
            self.consoleTextView.text = self.consoleTextView.text + "\n" + text
        }
    }
    
    func testReading() {
        write(toConsole: "testing on main queue, busy...")
        DispatchQueue.main.async {
            let startTime = Date()
            guard let containers = try? self.store.containers(matching: nil) else {
                self.write(toConsole: "failed fetching containers. please check \(#file):\(#line)\n")
                return
            }
            let keysToFetch: [CNKeyDescriptor] = [
                CNContactPhoneNumbersKey as CNKeyDescriptor,
                CNContactFormatter.descriptorForRequiredKeys(for: .fullName),
            ]
            var contacts: [CNContact] = []
            for container in containers {
                let predicate = CNContact.predicateForContactsInContainer(withIdentifier: container.identifier)
                guard let unifiedContacts = try? self.store.unifiedContacts(matching: predicate, keysToFetch: keysToFetch) else { continue }
                contacts += unifiedContacts
            }
            let endTime = Date()
            self.write(toConsole: "testing ended. read \(contacts.count) contacts costs \(endTime.timeIntervalSince(startTime))s.\n")
        }
    }
    
}

extension ViewController: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return names.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        var cell: UITableViewCell
        if let c = tableView.dequeueReusableCell(withIdentifier: "cell") {
            cell = c
        } else {
            cell = UITableViewCell(style: .subtitle, reuseIdentifier: "cell")
        }
        cell.textLabel?.text = names[indexPath.row]
        cell.detailTextLabel?.text = phoneNumbers[indexPath.row]
        return cell
    }

}
